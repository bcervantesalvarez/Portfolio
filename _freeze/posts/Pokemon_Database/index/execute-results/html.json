{
  "hash": "630c40df8bad41d96fe74e744bb39bde",
  "result": {
    "markdown": "---\ntitle: \"Pokédex Database\"\nauthor: \"Brian Cervantes Alvarez\"\ndescription: \"Unveil the power of PostgreSQL! Explore the intricate ETL process, advanced tools, and meticulous schema design that created a functional database. Join the journey of unraveling Pokémon mysteries through data engineering.\"\ndate: \"12-05-2022\"\nbibliography: \"bibliography.bib\"\nnocite: |\n     @*\nformat:\n  html:\n    toc: true\n    toc-location: right\n    html-math-method: katex\nimage: pokemon.jpeg\noutput: html_document\ncategories: [R, PostgreSQL, Data Visualization]\n---\n\n\n![](pokemon.jpeg)\n\n<div class=\"download-buttons\" style=\"text-align: center;\">\n  <style>\n    .download-buttons a.button {\n      display: inline-block;\n      padding-right: 10px;\n      padding-left: 35px;\n      padding-top: 10px;\n      padding-bottom: 10px;\n      margin-right: 25px;\n      background-color: #343a40;\n      color: #fff;\n      text-decoration: none;\n      border-radius: 15px;\n      position: relative;\n    }\n\n    .download-buttons a.button:last-child {\n      margin-right: 0;\n    }\n\n    .download-buttons a.button:hover {\n      background-color: #55595c;\n    }\n\n    .download-buttons a.button:after {\n      content: \"\\2193\";\n      font-size: 20px;\n      position: absolute;\n      top: 50%;\n      left: 12px; /* Added margin from the text */\n      transform: translateY(-50%);\n      border-bottom: 2px solid #fff;\n      padding: 1px; /* Padding for the mini border block */\n    }\n  </style>\n\n  <script>\n    function createDynamicButton(href, text) {\n      var button = document.createElement(\"a\");\n      button.href = href;\n      button.className = \"button\";\n      button.appendChild(document.createTextNode(text));\n      return button;\n    }\n\n    var downloadButtonsDiv = document.querySelector(\".download-buttons\");\n\n    var documentButton = createDynamicButton(\n      \"https://github.com/bcervantesalvarez/Portfolio/blob/main/posts/Pokemon_Database/index.qmd\",\n      \"Download .qmd\"\n    );\n    downloadButtonsDiv.appendChild(documentButton);\n\n    var csvButton = createDynamicButton(\n      \"https://github.com/bcervantesalvarez/Portfolio/blob/main/posts/Pokemon_Database/pokedex_presentation.jpg\",\n      \"Download .jpg\"\n    );\n    downloadButtonsDiv.appendChild(csvButton);\n  </script>\n</div>\n\n## Purpose\n\nThe main objective of this project was to construct a fully operational Postgresql database in a time frame of fewer than two weeks by employing the Extract, Transform, Load (ETL) methodology. The purpose of this approach was to extract data from various sources, transform it into a format that could be easily integrated into the database, and finally load the transformed data into the database.\n\nThe process involved several intricate steps, including identifying the relevant data sources, cleansing the extracted data to remove inconsistencies, standardizing the data to a uniform format, and applying data validation and verification techniques to ensure accuracy and completeness. Furthermore, it required careful consideration of the database schema, including the design of tables, relationships between tables, and the use of appropriate data types.\n\nThe successful implementation of this project was dependent on the utilization of cutting-edge technologies and tools, such as data integration software, data profiling tools, and scripting languages. The result was a functional database that can efficiently store and manage data, making it readily available for analysis, decision-making, and reporting purposes.\n\n## Summary\n\nThe inquiry of identifying the optimal base stat Pokemon type sparked my interest, prompting me to delve into the realm of data engineering. In order to craft a well-informed response to this question, I began by utilizing the expansive and multifaceted \"Pokémon of Kanto, Johto, and Hoenn Region\" dataset to establish a structured and organized database.\n\n\n## Unleashing the Power of PostgreSQL: Building a Database\n\nThis SQL code creates several tables for storing Pokémon data. The tables include information about Pokémon, their types, abilities, generations, and moves. The code establishes primary keys, foreign key constraints, and defines the data types for each column. These tables form the foundation for a comprehensive Pokémon database, enabling efficient storage and retrieval of Pokémon-related information.\n\n\n\n\n\n## Data Transformation and CSV Preparation in SQL: A Step-by-Step Guide\n\nThis section of the SQL file focuses on transforming and preparing a CSV file for analysis. It involves multiple SELECT statements that extract relevant data from different tables and join them together. The extracted data is then inserted into temporary tables, including 'temp1', 'temp2', and 'temp3', with each step refining the data further. Finally, the transformed data in 'temp3' is selected and filtered based on specific conditions, ordered, and then exported to a CSV file named 'scuffed_pokedex.csv'. This process prepares the data for further analysis and exploration in external tools or applications.\n\n\n::: {.cell}\n\n```{.sql .cell-code}\n\nSELECT \n    identifier AS pokemon_name, \n    pokemon_types.type_id,\n    pokemon_abilities.ability_id\nINTO temp1\nFROM pokemon\nLEFT JOIN pokemon_types\nON pokemon.id = pokemon_types.pokemon_id\nLEFT JOIN pokemon_abilities\nON pokemon.id  = pokemon_abilities.pokemon_id;\n\n\nSELECT \n    pokemon_name,\n    types.identifier AS pokemon_type,\n    abilities.identifier AS pokemon_ability,\n    types.generation_id AS gen_id,\n    types.id AS type_id\nINTO temp2\nFROM temp1\nLEFT JOIN types\nON temp1.type_id = types.id\nLEFT JOIN abilities\nON temp1.ability_id = abilities.id;\n\n\nDROP TABLE temp3;\nSELECT \n    pokemon_name,\n    pokemon_type,\n    pokemon_ability,\n    generations.identifier AS pokemon_generation,\n    moves.identifier AS pokemon_move,\n    moves.power AS pokemon_power,\n    moves.accuracy AS pokemon_accuracy,\n    moves.pp AS pokemon_pp\nINTO temp3\nFROM temp2\nLEFT JOIN generations\nON temp2.gen_id = generations.main_region_id\nLEFT JOIN moves\nON temp2.type_id = moves.type_id;\n\nSELECT *\nFROM temp3\nWHERE pokemon_power IS NOT NULL \n    AND pokemon_accuracy IS NOT NULL\nORDER BY pokemon_accuracy, pokemon_power;\n\n\nCOPY temp3\nTO '/Users/Shared/Data_503/Datasets/scuffed_pokedex.csv'\nWITH (FORMAT CSV, HEADER);\n```\n:::\n\n\n## Unveiling Pokémon Insights: Analyzing Damage Output and Accuracy\n\nThrough the power of data analysis and visualization, we have delved into the world of Pokémon to uncover insights about types, damage output, accuracy, and their relationships. Our exploration has shed light on the best Pokémon type for damage output, the most accurate contenders, and the interplay between power and accuracy. By combining the captivating nature of Pokémon with the analytical capabilities of R, we have gained valuable knowledge and set the stage for further investigations in the vast Pokémon universe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(RColorBrewer)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npokemon <- read_csv(\"scuffed_pokedex.csv\")\n\nnames(pokemon)\n\nnb.cols <- 18\nmycolors <- colorRampPalette(brewer.pal(8, \"YlOrRd\"))(nb.cols)\n\npokemon %>% \n  mutate(pokemon_type = str_to_title(pokemon_type)) %>%\n  group_by(pokemon_type) %>%\n  summarise(avg_power = mean(pokemon_power, na.rm = TRUE),\n            avg_accuracy = mean(pokemon_accuracy, na.rm = TRUE)) %>%\n  ggplot(aes(x = avg_power, y = reorder(pokemon_type, avg_power), fill = reorder(pokemon_type, avg_power)))+\n  geom_col(show.legend = FALSE, color = \"black\") +\n  labs(x = \"Average power\",\n       y = \"Pokemon type\",\n       title = \"FIRE! The Best Pokemon Type For Damage Output Is...?\",\n       subtitle = \"Based on an Average of All Moves Per Pokemon Type\",\n       caption = \"Source: Pokédex of Kanto, Johto, and Hoenn Regions @ Kaggle.com\") +\n  scale_fill_manual(values = mycolors) +\n  theme(plot.background = element_blank(),\n        panel.background = element_blank(),\n        axis.ticks.y = element_blank(),\n        panel.grid.major.x = element_line(color = \"grey\"))\n\n\nnb.cols <- 18\nmycolors <- colorRampPalette(brewer.pal(8, \"Blues\"))(nb.cols)\n\npokemon %>% \n  mutate(pokemon_type = str_to_title(pokemon_type)) %>%\n  group_by(pokemon_type) %>%\n  summarise(avg_power = mean(pokemon_power, na.rm = TRUE),\n            avg_accuracy = mean(pokemon_accuracy, na.rm = TRUE)) %>%\n  ggplot(aes(x = avg_accuracy, y = reorder(pokemon_type, avg_accuracy), fill = reorder(pokemon_type, avg_accuracy)))+\n  geom_col(show.legend = FALSE, color = \"black\") +\n  labs(x = \"Average accuracy\",\n       y = \"Pokemon type\",\n       title = \"Ouch! Who wins the bullseye competition?\",\n       subtitle = \"Based on an Average of All Moves Per Pokemon Type\",\n       caption = \"Source: Pokédex of Kanto, Johto, and Hoenn Regions @ Kaggle.com\") +\n  scale_fill_manual(values = mycolors) +\n  theme(plot.background = element_blank(),\n        panel.background = element_blank(),\n        axis.ticks.y = element_blank(),\n        panel.grid.major.x = element_line(color = \"grey\"))\n\n\npokemon %>% \n  group_by(pokemon_type) %>%\n  summarise(avg_power = mean(pokemon_power, na.rm = TRUE),\n            avg_accuarcy = mean(pokemon_accuracy, na.rm = TRUE)) %>%\n  ggplot(aes(x = avg_power, y = avg_accuarcy, color = pokemon_type)) +\n  geom_point()\n\n\nstats <- pokemon %>% \n  group_by(pokemon_type) %>%\n  summarise(avg_power = mean(pokemon_power, na.rm = TRUE),\n            avg_accuarcy = mean(pokemon_accuracy, na.rm = TRUE))\n            \nmodel <- lm(data = stats, avg_accuracy ~ avg_power)\nplot(model)\n```\n:::\n\n\n## Presentation\n\n![](pokedex_presentation.jpg)\n\n## Data References\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}